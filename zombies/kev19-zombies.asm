.data
maze:	.ascii
	# 0123456701234567012345670123456701234567012345670123456701234567
	 "  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",    # 0
	 "       xx      xx      xx      xx      xx      xx      xx      x",    # 1
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 2
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 3
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 4
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 5
	 "x                                                              x",    # 6
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 7
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 8
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 9
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 10
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 11
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 12
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 13
	 "x                                                              x",    # 14
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 15
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 16
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 17
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 18
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 19
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 20
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 21
	 "x                                                              x",    # 22
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 23
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 24
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 25
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 26
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 27
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 28
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 29
	 "x                                                              x",    # 30
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 31
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 32
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 33
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 34
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 35
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 36
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 37
	 "x                                                              x",    # 38
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 39
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 40
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 41
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 42
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 43
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 44
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 45
	 "x                                                              x",    # 46
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 47
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 48
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 49
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 50
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 51
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 52
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 53
	 "x                                                              x",    # 54
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 55
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 56
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 57
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 58
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 59
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 60
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 61
	 "x                                                               ",    # 62
	 "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  "     # 63
	# for each "x", turn the corresponding LED to orange.  The other LEDs should
	# be set to off.

m_win: .asciiz "Success! You won! Your score is "
m_win2: .asciiz " moves."

.text
# Draw maze
jal	_drawMaze

# Put zombies in start positions:
li	$a1, 4
li	$v0, 42
syscall
move	$s4, $a0		# Random number between 0-3 for beginning direction
li	$a0, 17
li	$a1, 14
li	$a2, 1
sll	$s4, $s4, 8
or	$s4, $s4, $a1
sll	$s4, $s4, 8
or	$s4, $s4, $a0
jal	_setLED


li	$a1, 4
li	$v0, 42
syscall
move	$s5, $a0
li	$a0, 49
li	$a1, 14
sll	$s5, $s5, 8
or	$s5, $s5, $a1
sll	$s5, $s5, 8
or	$s5, $s5, $a0
jal	_setLED

li	$a1, 4
li	$v0, 42
syscall
move	$s6, $a0
li	$a0, 17
li	$a1, 46
sll	$s6, $s6, 8
or	$s6, $s6, $a1
sll	$s6, $s6, 8
or	$s6, $s6, $a0
jal	_setLED

li	$a1, 4
li	$v0, 42
syscall
move	$s7, $a0
li	$a0, 49
li	$a1, 46
sll	$s7, $s7, 8
or	$s7, $s7, $a1
sll	$s7, $s7, 8
or	$s7, $s7, $a0
jal	_setLED


# Put player in start position:
li	$a0, 0
li	$a1, 0
li	$a2, 3
jal	_setLED

# Start game
jal	_start

# Get starting time:
li	$v0, 30
syscall
move	$s3, $a0		# Register $s3 = time
addi	$s3, $s3, 500		# Add 500 ms to original time

# Reset arguments for polling
li	$s0, 0			# Register $s0 = player's x position
li 	$s1, 0			# Register $s1 = player's y position
li	$s2, 0			# Register $s2 = number of moves

Loop: # $s0 - player x; $s1 - player y; $s2 - zombie1 x; $s3 - current time + 500ms
	move	$a0, $s0	# Set argument for _poll function
	move	$a1, $s1	# Set argument for _poll function
	jal	_poll		# Poll for button presses
	move	$s0, $v0	# Save new x position
	move	$s1, $v1	# Save new y position
	move	$t0, $s0
	move	$t1, $s1
	subi	$t0, $t0, 63
	subi	$t1, $t1, 63
	or	$t2, $t1, $t0
	beqz	$t2, _win
	li	$v0, 30		# Get time
	syscall
	blt	$a0, $s3, Loop	# If current time < original time + 500ms, loop again
	move	$a0, $s0
	move	$a1, $s1
	jal	_getQuad
	move	$a3, $v0
	move	$a1, $s1
	move	$a0, $s0
	beq	$a3, 0, _chase0
	beq	$a3, 1, _chase1
	beq	$a3, 2, _chase2
	beq	$a3, 3, _chase3


_chase0:
	move	$a2, $s4
	li	$a3, 0x1e1e0000
	jal	_zombieChase
	move	$s4, $v0

	move	$a0, $s5
	li	$a3, 0x1e003e20
	jal	_zombieRoam
	move	$s5, $v0

	move	$a0, $s6
	li	$a3, 0x3e201e00
	jal	_zombieRoam
	move	$s6, $v0

	move	$a0, $s7
	li	$a3, 0x3e203e20
	jal	_zombieRoam
	move	$s7, $v0


	li $v0, 30
	syscall
	addi	$s3, $a0, 500	# Save returned time
	j	Loop		# And then loop again

_chase1:
	move	$a2, $s5
	li	$a3, 0x1f003f20
	jal	_zombieChase
	move	$s5, $v0

	move	$a0, $s4
	li	$a3, 0x1f1f0000
	jal	_zombieRoam
	move	$s4, $v0

	move	$a0, $s6
	li	$a3, 0x3f201f00
	jal	_zombieRoam
	move	$s6, $v0

	move	$a0, $s7
	li	$a3, 0x3f203f20
	jal	_zombieRoam
	move	$s7, $v0

	li $v0, 30
	syscall
	addi	$s3, $a0, 500	# Save returned time
	j	Loop		# And then loop again

_chase2:
	move	$a2, $s6
	li	$a3, 0x3f201f00
	jal	_zombieChase
	move	$s6, $v0

	move	$a0, $s4
	li	$a3, 0x1f1f0000
	jal	_zombieRoam
	move	$s4, $v0

	move	$a0, $s5
	li	$a3, 0x1f003f20
	jal	_zombieRoam
	move	$s5, $v0

	move	$a0, $s7
	li	$a3, 0x3f203f20
	jal	_zombieRoam
	move	$s7, $v0

	li $v0, 30
	syscall
	addi	$s3, $a0, 500	# Save returned time
	j	Loop		# And then loop again

_chase3:
	move	$a2, $s7
	li	$a3, 0x3f203f20
	jal	_zombieChase
	move	$s7, $v0

	move	$a0, $s4
	li	$a3, 0x1f1f0000
	jal	_zombieRoam
	move	$s4, $v0

	move	$a0, $s5
	li	$a3, 0x1f003f20
	jal	_zombieRoam
	move	$s5, $v0

	move	$a0, $s6
	li	$a3, 0x3f201f00
	jal	_zombieRoam
	move	$s6, $v0

	li $v0, 30
	syscall
	addi	$s3, $a0, 500	# Save returned time
	j	Loop		# And then loop again

_zombieChase:
	addi	$sp, $sp, -20
	sw	$ra, 0($sp)
	sw	$s0, 4($sp)
	sw	$s1, 8($sp)
	sw	$s2, 12($sp)
	sw	$s3, 16($sp)
	move	$t0, $a0		# Player x
	move	$t1, $a1		# Player y
	move	$t3, $a2		# Zombie position

	# Get x and y bounds from $a3
	andi	$s0, $a3, 0x000000ff	# $s0 - lower x bound
	andi	$s1, $a3, 0x0000ff00
	srl	$s1, $s1, 8		# $s1 - upper x bound
	andi	$s2, $a3, 0x00ff0000
	srl	$s2, $s2, 16		# $s2 - lower y bound
	andi	$s3, $a3, 0xff000000
	srl	$s3, $s3, 24		# $s3 - upper y bound


	# Get position of chaser
	andi	$t4, $t3, 0x000000ff	# $t4 - zombie x
	srl	$t3, $t3, 8
	andi	$t5, $t3, 0x000000ff	# $t5 - zombie y
	sub	$t6, $t0, $t4		# $t6 = Xp - Xz
	beqz	$t6, _moveY
	sub	$t7, $t1, $t5		# $t7 = Yp - Yz
	beqz	$t7, _moveX
	abs	$t8, $t6		# $t8 = |$t6|
	abs	$t9, $t7		# $t9 = |$t7|
	bgt	$t8, $t9, _moveX
	j	_moveY

_moveX:
	bltz	$t6, _moveLeft
	j	_moveRight

_moveLeft:
	subi	$t8, $t4, 1
	blt	$t8, $s0, _moveUp
	move	$a0, $t8
	move	$a1, $t5
	jal	_getLED			# $v0 = LED color
	beq	$v0, 2, _moveY
	li	$a2, 1
	jal	_setLED			# Turn on LED at ((Xz-1), Yz)
	addi	$a0, $a0, 1
	li	$a2, 0
	jal	_setLED			# Turn off LED at (Xz, Yz)

	li	$v0, 0
	sll	$v0, $v0, 8
	or	$v0, $v0, $a1
	sll	$v0, $v0, 8
	or	$v0, $v0, $t8		# Return new position of zombie
	j	_chaseExit

_moveRight:
	addi	$t8, $t4, 1
	bgt	$t8, $s1, _moveY
	move	$a0, $t8
	move	$a1, $t5
	jal	_getLED			# $v0 = LED color
	beq	$v0, 2, _moveY
	li	$a2, 1
	jal	_setLED			# Turn on LED at ((Xz-1), Yz)
	subi	$a0, $a0, 1
	li	$a2, 0
	jal	_setLED			# Turn off LED at (Xz, Yz)

	li	$v0, 1
	sll	$v0, $v0, 8
	or	$v0, $v0, $a1
	sll	$v0, $v0, 8
	or	$v0, $v0, $t8		# Return new position of zombie
	j	_chaseExit

_moveY:
	bgtz	$t7, _moveDown
	j	_moveUp

_moveUp:
	subi	$t8, $t5, 1
	ble	$t8, $s2, _moveX
	move	$a1, $t8
	move	$a0, $t4
	jal	_getLED			# $v0 = LED color
	beq	$v0, 2, _moveX
	li	$a2, 1
	jal	_setLED			# Turn on LED at (Xz, (Yz-1))
	addi	$a1, $a1, 1
	li	$a2, 0
	jal	_setLED			# Turn off LED at (Xz, Yz)

	li	$v0, 2
	sll	$v0, $v0, 8
	or	$v0, $v0, $t8
	sll	$v0, $v0, 8
	or	$v0, $v0, $a0		# Return new position of zombie
	j	_chaseExit

_moveDown:
	addi	$t8, $t5, 1
	bge	$t8, $s3, _moveX
	move	$a1, $t8
	move	$a0, $t4
	jal	_getLED			# $v0 = LED color
	beq	$v0, 2, _moveX
	li	$a2, 1
	jal	_setLED			# Turn on LED at (Xz, (Yz+1))
	subi	$a1, $a1, 1
	li	$a2, 0
	jal	_setLED			# Turn off LED at (Xz, Yz)

	li	$v0, 3
	sll	$v0, $v0, 8
	or	$v0, $v0, $t8
	sll	$v0, $v0, 8
	or	$v0, $v0, $a0		# Return new position of zombie
	j	_chaseExit

_chaseExit:
	lw	$s3, 16($sp)
	lw	$s2, 12($sp)
	lw	$s1, 8($sp)
	lw	$s0, 4($sp)
	lw	$ra, 0($sp)
	addi	$sp, $sp, 20
	jr	$ra

_zombieRoam: # $v0 - new zombie position; $v1 - current direction
	addi	$sp, $sp, -12
	sw	$ra, 0($sp)
	move	$t0, $a0

	# Get position of roamer
	andi	$t1, $t0, 0x000000ff	# $t1 - zombie x
	srl	$t0, $t0, 8
	andi	$t2, $t0, 0x000000ff	# $t2 - zombie y
	srl	$t0, $t0, 8
	andi	$t3, $t0, 0x000000ff	# $t3 - current direction

	andi	$t5, $a3, 0x000000ff	# $s0 - lower x bound
	andi	$t6, $a3, 0x0000ff00
	srl	$t6, $t6, 8		# $s1 - upper x bound
	andi	$t7, $a3, 0x00ff0000
	srl	$t7, $t7, 16		# $s2 - lower y bound
	andi	$t8, $t8, 0xff000000
	srl	$t8, $t8, 24		# $s3 - upper y bound

_roamDirection:
	beqz	$t3, _roamLeft
	beq	$t3, 1, _roamRight
	beq	$t3, 2, _roamUp
	beq	$t3, 3, _roamDown
	j	_roamExit

_roamLeft:
	subi	$t4, $t1, 1
	blt	$t4, $t5, _roamLbound	# Check if in bounds
	move	$a0, $t4
	move	$a1, $t2
	sw	$t1, 4($sp)
	sw	$t2, 8($sp)
	jal	_getLED			# $v0 = LED color
	lw	$t2, 8($sp)
	lw	$t1, 4($sp)
	beq	$v0, 2, _roamUp
	li	$a2, 1
	jal	_setLED			# Turn on LED at ((Xz-1), Yz)
	addi	$a0, $a0, 1
	li	$a2, 0
	jal	_setLED			# Turn off LED at (Xz, Yz)

	li	$v0, 0
	sll	$v0, $v0, 8
	or	$v0, $v0, $a1
	sll	$v0, $v0, 8
	or	$v0, $v0, $t4		# Return new position of zombie
	j	_roamExit

_roamRight:
	addi	$t4, $t1, 1
	bgt	$t4, $t6, _roamRbound	# Check if in bounds
	move	$a0, $t4
	move	$a1, $t2
	sw	$t1, 4($sp)
	sw	$t2, 8($sp)
	jal	_getLED			# $v0 = LED color
	lw	$t2, 8($sp)
	lw	$t1, 4($sp)
	beq	$v0, 2, _roamDown
	li	$a2, 1
	jal	_setLED			# Turn on LED at ((Xz-1), Yz)
	subi	$a0, $a0, 1
	li	$a2, 0
	jal	_setLED			# Turn off LED at (Xz, Yz)

	li	$v0, 1
	sll	$v0, $v0, 8
	or	$v0, $v0, $a1
	sll	$v0, $v0, 8
	or	$v0, $v0, $t4		# Return new position of zombie
	j	_roamExit

_roamUp:
	subi	$t4, $t2, 1
	ble	$t4, $t7, _roamUbound
	move	$a1, $t4
	move	$a0, $t1
	sw	$t1, 4($sp)
	sw	$t2, 8($sp)
	jal	_getLED			# $v0 = LED color
	lw	$t2, 8($sp)
	lw	$t1, 4($sp)
	beq	$v0, 2, _roamRight
	li	$a2, 1
	jal	_setLED			# Turn on LED at ((Xz-1), Yz)
	addi	$a1, $a1, 1
	li	$a2, 0
	jal	_setLED			# Turn off LED at (Xz, Yz)

	li	$v0, 2
	sll	$v0, $v0, 8
	or	$v0, $v0, $t4
	sll	$v0, $v0, 8
	or	$v0, $v0, $a0		# Return new position of zombie
	j	_roamExit

_roamDown:
	addi	$t4, $t2, 1
	bge	$t4, $t8, _roamDbound	# Check if in bounds
	move	$a1, $t4
	move	$a0, $t1
	sw	$t1, 4($sp)
	sw	$t2, 8($sp)
	jal	_getLED			# $v0 = LED color
	lw	$t2, 8($sp)
	lw	$t1, 4($sp)
	beq	$v0, 2, _roamLeft
	li	$a2, 1
	jal	_setLED			# Turn on LED at ((Xz-1), Yz)
	subi	$a1, $a1, 1
	li	$a2, 0
	jal	_setLED			# Turn off LED at (Xz, Yz)

	li	$v0, 3
	sll	$v0, $v0, 8
	or	$v0, $v0, $t4
	sll	$v0, $v0, 8
	or	$v0, $v0, $a0		# Return new position of zombie
	j	_roamExit

_roamLbound:
	# Try up first
	subi	$t4, $t2, 1
	blt	$t4, $t7, _roamUbound
	move	$a1, $t4
	move	$a0, $t1
	sw	$t1, 4($sp)
	sw	$t2, 8($sp)
	jal	_getLED
	lw	$t2, 8($sp)
	lw	$t1, 4($sp)
	bne	$v0, 2, _roamUp

	# Next, try down
	addi	$t4, $t2, 1
	bgt	$t4, $t8, _roamDbound
	move	$a1, $t4
	move	$a0, $t1
	sw	$t1, 4($sp)
	sw	$t2, 8($sp)
	jal	_getLED
	lw	$t2, 8($sp)
	lw	$t1, 4($sp)
	bne	$v0, 2, _roamDown

	# Lastly, try right
	addi	$t4, $t1, 1
	bgt	$t4, $t5, _roamRbound
	move	$a0, $t4
	move	$a1, $t2
	sw	$t1, 4($sp)
	sw	$t2, 8($sp)
	jal	_getLED
	lw	$t2, 8($sp)
	lw	$t1, 4($sp)
	bne	$v0, 2, _roamRight

_roamRbound:
	# Try down first
	addi	$t4, $t2, 1
	bgt	$t4, $t8, _roamDbound
	move	$a1, $t4
	move	$a0, $t1
	sw	$t1, 4($sp)
	sw	$t2, 8($sp)
	jal	_getLED
	lw	$t2, 8($sp)
	lw	$t1, 4($sp)

	bne	$v0, 2, _roamDown

	# Next, try up
	subi	$t4, $t2, 1
	blt	$t4, $t7, _roamUbound
	move	$a1, $t4
	move	$a0, $t1
	sw	$t1, 4($sp)
	sw	$t2, 8($sp)
	jal	_getLED
	lw	$t2, 8($sp)
	lw	$t1, 4($sp)
	bne	$v0, 2, _roamUp

	# Lastly, try left
	subi	$t4, $t1, 1
	blt	$t4, $t6, _roamLbound
	move	$a0, $t4
	move	$a1, $t2
	sw	$t1, 4($sp)
	sw	$t2, 8($sp)
	jal	_getLED
	lw	$t2, 8($sp)
	lw	$t1, 4($sp)
	bne	$v0, 2, _roamLeft

_roamUbound:
	# Try right first
	addi	$t4, $t1, 1
	bgt	$t4, $t5, _roamRbound
	move	$a0, $t4
	move	$a1, $t2
	sw	$t1, 4($sp)
	sw	$t2, 8($sp)
	jal	_getLED
	lw	$t2, 8($sp)
	lw	$t1, 4($sp)
	bne	$v0, 2, _roamRight

	# Next, try left
	subi	$t4, $t1, 1
	blt	$t4, $t6, _roamLbound
	move	$a0, $t4
	move	$a1, $t2
	sw	$t1, 4($sp)
	sw	$t2, 8($sp)
	jal	_getLED
	lw	$t2, 8($sp)
	lw	$t1, 4($sp)
	bne	$v0, 2, _roamLeft

	# Lastly, try down
	addi	$t4, $t2, 1
	bgt	$t4, $t8, _roamDbound
	move	$a1, $t4
	move	$a0, $t1
	sw	$t1, 4($sp)
	sw	$t2, 8($sp)
	jal	_getLED
	lw	$t2, 8($sp)
	lw	$t1, 4($sp)
	bne	$v0, 2, _roamDown

_roamDbound:
	# Try left first
	subi	$t4, $t1, 1
	blt	$t4, $t6, _roamLbound
	move	$a0, $t4
	move	$a1, $t2
	sw	$t1, 4($sp)
	sw	$t2, 8($sp)
	jal	_getLED
	lw	$t2, 8($sp)
	lw	$t1, 4($sp)
	bne	$v0, 2, _roamLeft

	# Next, try right
	addi	$t4, $t1, 1
	bgt	$t4, $t5, _roamRbound
	move	$a0, $t4
	move	$a1, $t2
	sw	$t1, 4($sp)
	sw	$t2, 8($sp)
	jal	_getLED
	lw	$t2, 8($sp)
	lw	$t1, 4($sp)
	bne	$v0, 2, _roamRight

	# Lastly, try up
	subi	$t4, $t2, 1
	blt	$t4, $t7, _roamUbound
	move	$a1, $t4
	move	$a0, $t1
	sw	$t1, 4($sp)
	sw	$t2, 8($sp)
	jal	_getLED
	lw	$t2, 8($sp)
	lw	$t1, 4($sp)
	bne	$v0, 2, _roamUp

_roamExit:
	lw	$ra, 0($sp)
	addi	$sp, $sp, 12
	jr	$ra																																														

#_getQuad procedure:
#---------------------------------------------------------------
_getQuad:
	slti	$t0, $a0, 32	# $t0 = 1 if in 0th or 2nd quardrant; $t0 = 0 if in 1st or 3rd
	slti	$t1, $a1, 32	# $t1 = 1 if in 0th or 1st quadrant; $t1 = 0 if in 2nd or 3rd

	and	$t2, $t0, $t1
	beq	$t2, 1, _quad0

	not	$t2, $t0
	and	$t2, $t2, $t1
	beq	$t2, 1, _quad1

	not	$t2, $t1
	and	$t2, $t2, $t0
	beq	$t2, 1, _quad2

	nor	$t2, $t0, $t1
	beq	$t2, 1, _quad3


_quad0:	li	$v0, 0
	jr	$ra

_quad1:	li	$v0, 1
	jr	$ra

_quad2:	li	$v0, 2
	jr	$ra

_quad3:	li	$v0, 3
	jr	$ra

# End procedure-----------------------


# _win procedure:
#---------------------------------------
_win:
	la	$a0, m_win
	li	$v0, 4
	syscall
	move	$a0, $s2
	li	$v0, 1
	syscall
	la	$a0, m_win2
	li	$v0, 4
	syscall
	li $v0, 10
	syscall
# End procedure--------------------------


# _start procedure:
#----------------------------------------
_start:
	la	$v0,0xffff0000
	lw	$t0,0($v0)		# Read the key press status
	andi	$t0,$t0,1
	beq	$t0,$0,_start		# No key pressed
	lw	$t0,4($v0)		# Read key value
	addi	$v0,$t0,-66		# Check for middle (b) key press
	bne	$v0,$0,_start		# If not middle key, continue polling
	jr	$ra			# If it is middle key, give control back to main program to start the game

# End procedure---------------------------


# _poll procedure
#-----------------------------------------
_poll:
	addi	$sp, $sp, -4
	sw	$ra, 0($sp)
	la	$t8,0xffff0000		# Address for reading key press status
	lw	$t0,0($t8)		# Read the key press status
	andi	$t0,$t0,1
	move	$v0, $a0		# Return current y position of player
	move	$v1, $a1		# Return current x position of player
	beq	$t0,$0,_poll_exit	# No key pressed
	lw	$t0,4($t8)		# Read key value
	li	$a2, 3
ukey:
	addi	$t8,$t0,-224		# Check for down key press
	bne	$t8,$0,dkey		# Wasn't up key, so try down key
	addi	$a1, $a1, -1		# Subtract 1 from y position
	jal	_getLED			# Get color of LED
	move	$t7, $v0
	beq	$t7, 2, _poll_exit_wall	# If attempted move runs into a wall, don't do anything and loop again
	jal	_setLED			# Otherwise, set new position
	addi	$s2, $s2, 1		# Increment number of moves
	move	$v0, $a0		# Return current y position of player
	move	$v1, $a1		# Return current x position of player
	li	$a2, 0			# Change color to off
	addi	$a1, $a1, 1		# Return position to where player used to be
	jal	_setLED			# And turn off last position
	j	_poll_exit		# Exit

dkey:
	addi	$t8,$t0,-225		# Check for up key press
	bne	$t8,$0,lkey		# Wasn't down key, so try left key
	addi	$a1, $a1, 1		# Add 1 to y position
	jal	_getLED			# Get color of LED
	move	$t7, $v0
	beq	$t7, 2, _poll_exit_wall	# If attempted move runs into a wall, don't do anything and loop again
	jal	_setLED			# Otherwise, set new position
	addi	$s2, $s2, 1		# Increment number of moves
	move	$v0, $a0		# Return current y position of player
	move	$v1, $a1		# Return current x position of player
	li	$a2, 0
	addi	$a1, $a1, -1
	jal	_setLED			# And turn off last position
	j	_poll_exit

lkey:
	addi	$t8,$t0,-226		# Check for left key press
	bne	$t8,$0,rkey		# Wasn't left key, so try right key
	addi	$a0, $a0, -1		# Subtract 1 from x position
	jal	_getLED			# Get color of LED
	move	$t7, $v0
	beq	$t7, 2, _poll_exit_wall	# If attempted move runs into a wall, don't do anything and loop again
	jal	_setLED			# Otherwise, set new position
	addi	$s2, $s2, 1		# Increment number of moves
	move	$v0, $a0		# Return current y position of player
	move	$v1, $a1		# Return current x position of player
	li	$a2, 0
	addi	$a0, $a0, 1
	jal	_setLED			# And turn off last position
	j	_poll_exit
rkey:
	addi	$t8,$t0,-227		# Check for right key press
	bne	$t8,$0,bkey		# Wasn't right key, so try middle key
	addi	$a0, $a0, 1		# Add 1 to x position
	jal	_getLED			# Get color of LED
	move	$t7, $v0
	beq	$t7, 2, _poll_exit_wall	# If attempted move runs into a wall, don't do anything and loop again
	jal	_setLED			# Otherwise, set new position
	addi	$s2, $s2, 1		# Increment number of moves
	move	$v0, $a0		# Return current y position of player
	move	$v1, $a1		# Return current x position of player
	li	$a2, 0
	addi	$a0, $a0, -1
	jal	_setLED			# And turn off last position
	j	_poll_exit
bkey:
	#addi	$t8,$t0,-66		# Check for middle (b) key press
	#bne	$t8,$0,_poll_exit	# Invalid key
	j	_poll_exit		# Not sure what to do yet

_poll_exit:
	lw	$ra, 0($sp)
	addi	$sp, $sp, 4
	jr 	$ra

_poll_exit_wall:
	move	$v0, $s0		# If player ran into wall, return original position
	move	$v1, $s1
	lw	$ra, 0($sp)
	addi	$sp, $sp, 4
	jr 	$ra

# End procedure-----------------------------


# _drawMaze procedure:
#--------------------------------------------
_drawMaze: # a0 - x, a1 - y, a2 - color
	addi	$sp, $sp, -4
	sw	$ra, 0($sp)
	li	$a1, -1			# Row index
	li	$a2, 2			# Color = yellow
	la	$t4, maze

_drawMaze_RLoop:
	addi	$a1, $a1, 1
	li	$a0, -1 		# Reset column index
	beq	$a1, 64, _drawMaze_exit
	j	_drawMaze_CLoop

_drawMaze_CLoop:
	addi	$a0, $a0, 1
	beq	$a0, 64, _drawMaze_RLoop
	lbu	$t1, ($t4)
	addi	$t4, $t4, 1
	bne	$t1, 0x78, _drawMaze_CLoop
	jal	_setLED
	j	_drawMaze_CLoop

_drawMaze_exit:
	lw	$ra, 0($sp)
	addi	$sp, $sp, 4
	jr	$ra
# End procedure-----------------------------------

# _setLED procedure:
#-------------------------------------------------
_setLED:
	# Byte offset into display = y * 16 bytes + (x / 4)
	sll	$t0,$a1,4      # y * 16 bytes
	srl	$t1,$a0,2      # x / 4
	add	$t0,$t0,$t1    # Byte offset into display
	li	$t2,0xffff0008 # Base address of LED display
	add	$t0,$t2,$t0    # Address of byte with the LED
	# Now, compute led position in the byte and the mask for it
	andi	$t1,$a0,0x3    # Remainder is led position in byte
	neg	$t1,$t1        # Negate position for subtraction
	addi	$t1,$t1,3      # Bit positions in reverse order
	sll	$t1,$t1,1      # LED is 2 bits
	# Compute two masks: one to clear field, one to set new color
	li	$t2,3
	sllv	$t2,$t2,$t1
	not	$t2,$t2        # Bit mask for clearing current color
	sllv	$t1,$a2,$t1    # Bit mask for setting color
	# Get current LED value, set the new field, store it back to LED
	lbu	$t3,0($t0)     # Read current LED value
	and	$t3,$t3,$t2    # Clear the field for the color
	or	$t3,$t3,$t1    # Set color field
	sb	$t3,0($t0)     # Update display
	jr	$ra
# End procedure-------------------------------------

# _getLED procedure:
	# int _getLED(int x, int y)
	#  Returns the value of the LED at position (x,y)
	#
	#  Arguments: $a0 holds x, $a1 holds y
	#  Trashes:   $t0-$t2
	#  Returns:   $v0 holds the value of the LED (0, 1, 2 or 3)
	#
_getLED:
	# Byte offset into display = y * 16 bytes + (x / 4)
	sll  $t0,$a1,4      # y * 16 bytes
	srl  $t1,$a0,2      # x / 4
	add  $t0,$t0,$t1    # Byte offset into display
	la   $t2,0xffff0008
	add  $t0,$t2,$t0    # Address of byte with the LED
	# Now, compute bit position in the byte and the mask for it
	andi $t1,$a0,0x3    # Remainder is bit position in byte
	neg  $t1,$t1        # Negate position for subtraction
	addi $t1,$t1,3      # Bit positions in reverse order
    	sll  $t1,$t1,1      # LED is 2 bits
	# Load LED value, get the desired bit in the loaded byte
	lbu  $t2,0($t0)
	srlv $t2,$t2,$t1    # Shift LED value to lsb position
	andi $v0,$t2,0x3    # Mask off any remaining upper bits
	jr   $ra
# End procedure--------------------------------------
